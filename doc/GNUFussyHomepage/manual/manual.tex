% ******************************************************************
%  * Copyright (c) 2000-2018, 2019 S.Bhatnagar
%  *
% #   This file is part of fussy.
% #
% #   fussy is a free software: you can redistribute it and/or modify
% #   it under the terms of the GNU General Public License as published by
% #   the Free Software Foundation, either version 3 of the License, or
% #   (at your option) any later version.
% #
% #   fussy is distributed in the hope that it will be useful,
% #   but WITHOUT ANY WARRANTY; without even the implied warranty of
% #   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% #   GNU General Public License for more details.
% #
% #   You should have received a copy of the GNU General Public License
% #   along with fussy.  If not, see <https://www.gnu.org/licenses/>.
%  *
% ******************************************************************
%\documentclass[]{acmtrans2m}
%\documentclass[acmtoms,acmnow]{acmtrans2m}
\documentclass[11pt]{article}
\renewcommand{\familydefault}{\sfdefault}
\usepackage{fancyhdr}     % Use Utopia font - used for printing the thesis
%\usepackage{utopia}     % Use Utopia font
\usepackage{ifpdf}
\usepackage{amsmath}
\usepackage[dvips]{graphicx, color}  % The figure package
\usepackage{palatino}
%\usepackage{txfonts}     % Use Utopia font
\usepackage{natbib}
\usepackage{marvosym}
\usepackage{xcolor}
\usepackage{enumitem}
\usepackage[breaklinks,colorlinks]{hyperref}

\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=gray,
    filecolor=black,
    linkcolor=blue,
    urlcolor=red
}

\raggedbottom

\setlength{\textheight}{22.0cm}
\setlength{\textwidth}{16.00cm}
\setlength{\topmargin}{-0.5cm}
\setlength{\oddsidemargin}{0.0cm}
\setlength{\evensidemargin}{0.5cm}
\setlength{\parskip}{5pt}
\setlength{\parindent}{20pt}

\newcommand{\Fussy}{GNU {\tt fussy}}
\newcommand{\DS}{{\tt DS}}
\newcommand{\VMS}{{\tt VMS}}
\newcommand{\PDFVersion}  {\htmladdnormallinkfoot{PDF version}{http://www.aoc.nrao.edu/~sbhatnag/Softwares/fussy/fussy.pdf}}
           
\pagestyle{fancyplain}
\rhead[]{Language with automatic error propagation}      % Note the different brackets!
\lhead[]{{\tt fussy}}
% \pagestyle{myheadings}
% %\markright{S. Bhatnagar}
% %\pagestyle{headings}
% \markboth{S. Bhatnagar}{Automatic random error propagation: S. Bhatnagar}


\begin{document}
\title{{\Fussy}: A language with automatic error propagation}
\author{S. Bhatnagar}
%\date{Nov. 2003}
\date{}
\maketitle
\normalsize
%% \ifpdf
%% \else
%% \begin{center}
%%   \PDFVersion
%% \end{center}
%% \fi

\begin{abstract} 
\pagestyle{empty} Formal propagation of random errors in a mathematical expression follow
a precise prescription based on calculus.  This requires the computation of the variation
of the function with respect to each of the independent variables used to construct the
function.  These variations are added in quadrature to compute the final numerical error.
For complicated expressions, computation of all the partial derivatives is often
cumbersome and hence error prone.

The \Fussy\footnote{The name reflects the original intention of designing a language for
  fuzzy arithmetic.  It is also a pun on those who (wrongly) consider error propagation
  as too much fuss!}  language implements an algorithm for automatic propagation of
random measurement errors in an arbitrary mathematical expression.  It is internally
implemented as a virtual machine for efficient run time performance and can be used as an
interpreter by the user.  A simple {\tt C} binding to the interpreter is also provided.
Mathematical expressions can be implemented as a collection of sub-expressions, as
sub-program units (functions or procedures) or as single atomic expressions.  Errors are
correctly propagated when a complex expression is broken up into smaller sub-expressions.
Sub-expressions are assigned to temporary variables which can then be used to write the
final expression.  These temporary variables are not independent variables and the
information about their dependence on other constituent independent variables is
preserved for error propagation.

The syntax of \Fussy\ is similar to that of the {\tt C} programming language.  It is
therefore easy to use with minimal learning and can be used in every day scientific work
and can be used as an interactive scientific calculator.
\end{abstract}
            
\newpage
\tableofcontents
\newpage

\section{Introduction}

Let $\vec x$ be a vector of independent experimentally measured
quantities with associated random measurement error  $\delta \vec
x$.  The formal error on a function $f(\vec x)$ is then given by
\begin{equation}
  \delta f = \sqrt{\left| \vec{\nabla f} \cdot \vec{\delta x}\right|^2} = \sqrt{\sum_i {\left( {\partial f \over {\partial x_i}} 
        \delta x_i \right)}^2}
\label{FERR}
\end{equation}
Further, if $f(\vec x)$ is a functional, e.g. $f(\vec x)=g(h(k(\vec
x)))$, the partial derivative of $f$ is given by the derivative
chain rule:
\begin{equation}
{\partial f \over \partial x_i} = {\partial g \over \partial h} 
{\partial h \over \partial k} {\partial k \over \partial x_i}
\label{DFUNCTIONAL}
\end{equation}
Therefore in general, to compute the propagated error $\delta f$ in the evaluation of $f$
requires:
\begin{enumerate}
\item the partial derivative of the function with respect to each
independent variable ($\partial f / \partial x_i$)
\item $\delta x_i$ - the measurement error
\item chain rules of differential calculus for the
mathematical operators 
\end{enumerate}


The \Fussy\ language internally maintains the information about dependent and independent
variables in a mathematical expression, computes the required derivatives and
automatically propagates the error in the final result.  The {\tt fussy} interpreter is
implemented internally as a stack-based virtual machine (VM) which maintains a stack
{\it per independent variable} to hold the intermediate partial derivatives.  At the
terminal nodes of a parsing tree (e.g.  the '{\tt =}' operator) the values from these
stacks are used to evaluate Eq.~\ref{FERR}.  A user program written in \Fussy\ is
compiled into the VM instruction-set, referred to as the op-codes, to manipulate the VM
stack (\VMS), call built-in functions, perform basic mathematical operations or call
user-defined sub-program (functions or procedures).  These op-codes are function calls
which perform the operation they represent (mathematical operators, built-in function
call or branching to a sub-program unit) along with the steps required for automatic
error propagation.  Since user-defined programs/expressions are compiled into these
op-codes, errors are correctly propagated in the mathematical expression in any arbitrary
user program.

A simple {\tt C} binding to the interpreter is also provided.  A {\tt fussy} program can be
supplied to the interpreter via an in-memory string with the following call
\begin{verbatim}
   calc(char *InString, edouble &ans, FILE *InStream, FILE *OutStream)  
\end{verbatim}

The contents of the {\tt InString} are parsed and converted to a VM
instruction set.  The result of the execution of this program is returned in {\tt ans}.
The last two arguments are not used in this case.  Alternatively, if {\tt InString} is
set to {\tt NULL} and the last two arguments set to valid file pointers, the interpreter
will take the input from {\tt InFile} and use {\tt OutFile} as the output stream.  A
similar {\tt C++} interface of type
\begin{verbatim}
   calc(char *InString, ostream &ResultStream, FILE *InStream, FILE *OutStream)
\end{verbatim}

writes the result of the program supplied in {\tt InString} or via the file pointer {\tt
  InStream} to the output stream {\tt ResultStream}.  {\tt OutStream} in both interfaces
is used as the output file for the error messages.

The sections below describe the usage of the \Fussy\ interpreter and the language
syntax. Section~\ref{SEC:EXAMPLES} contains a few examples demonstrating automatic error
propagation and Section~\ref{APPEN:SYNTAX} describes the {\tt fussy} syntax.


\subsection{Usage}
{\tt fussy [-h|--help] [-q] [-d] [-t N] [prog1,prog2,...]}

\begin{verbatim}
-h or --help
   Print this help

-q
   Run in quiet mode.  Do not print the copyright information

-d
   Sets the debugging mode (meant for developers)

-t N
   N is the number of Ctrl-C trials after which the interpreter
   gives up preaching good behavior and quits
\end{verbatim}

At start-up, the interpreter loads the contents of {\tt \$HOME/.fussy} file, if found.
Following this, the {\tt fussy} code in {\tt prog1}, {\tt prog2}, etc. is executed before the interpreter
enters interactive state (unless {\tt quit} is called in the code in any of the supplied
files).

Use the {\tt "help"} command in interactive mode to get more help about the language syntax.

\subsection{Configurable environment variables}

The {\tt fussy} program is sensitive to the following UNIX shell environment variables.

{\tt HOME}: The path from where the {\tt .fussy} file is loaded.

{\tt FUSSY\_IGNOREEOF} (default value = 1000000): This can be set to an integer value.  FUSSY\_IGNOREEOF number of
Ctrl-D inputs to the \Fussy\ interpreter will be ignored. \Fussy\ will exit on the next
Ctrl-D input.

\section{Examples}
\label{SEC:EXAMPLES}
Following are some examples to demonstrate that correctness of the error propagation
algorithm.  In the following examples functions are written in different algebraic forms
and the results for the different forms is shown to be exactly the same (e.g. $\cos(x)$
vs.  $\sqrt{1-\sin^2(x)}$, $\tan(x)$ vs. $\sin(x)/\cos(x)$).  Other examples verify that
the combination of a function and its inverse simply returns the argument (e.g
$asin(\sin(x))=x$), as well as functions like $\sinh(x)/((\exp(x)-\exp(-x))/2)$ evaluate
to a value of $1$ with no error (these are just a complicated way of writing $1$!).
However, if the value of two independent variates $x_1$ and $x_2$ and their
corresponding errors are the same, the value of expressions like $\sin^2(x_1) +
\cos^2(x_2)$ will evaluate to $1$ but the error will be non-zero.
\begin{verbatim}
   Value of x         =  1.00000 +/- 0.10000
   Value of y         =  2.00000 +/- 0.20000
   Value of x1        =  1.00000 +/- 0.10000
   Value of x2        =  1.00000 +/- 0.10000

   sin(x)             =  0.84147 +/-  0.05403
   sqrt(1-sin(x)^2)   =  0.54030 +/-  0.08415
   cos(x)             =  0.54030 +/-  0.08415

   tan(x)             =  1.55741 +/-  0.34255
   sin(x)/cos(x)      =  1.55741 +/-  0.34255

   sinh(x)            =  1.17520 +/-  0.15431
   (exp(x)-exp(-x))/2 =  1.17520 +/-  0.15431

   sin(x1)*sin(x1)       =  0.70807 +/- 0.09093
   sin(x1)*sin(x2)       =  0.70807 +/- 0.06430

   /* Expressions that evalute to just x */

   asin(sin(x))       =  1.00000 +/-  0.10000
   asinh(sinh(x))     =  1.00000 +/-  0.10000
   atanh(tanh(x))     =  1.00000 +/-  0.10000
   exp(ln(x))         =  1.00000 +/-  0.10000

   /* Complicated ways of computing 1.0! */

   sinh(x)/((exp(x)-exp(-x))/2) =  1.00000 
   x/exp(ln(x))                 =  1.00000

   /* Complicated ways of computing 1.0 with single and multiple variates! */

   sin(x1)^2+cos(x1)^2   =  1.00000 +/- 0.00000
   sin(x1)^2+cos(x2)^2   =  1.00000 +/- 0.12859
\end{verbatim}

\subsection{Recursion}

Following is an example of error propagation in a recursive function.
The factorial of $x$ is written as a recursive function $f(x)$.  Its
derivative is given by 
%\begin{equation}
%f^\prime(x)=f(x)\sum_{n=0}^{x-1}\frac{1}{x-n}
%\end{equation}
$f(x)\left[\frac{1}{x} + \frac{1}{x-1} + \frac{1}{x-2} +\cdots +
\frac{1}{2} + 1\right]$.  The term in the parenthesis is also written
as a recursive function $df(x)$.  It is shown that the propagated
error in $f(x)$ is equal to $f(x)df(x)\delta x$.
\begin{verbatim}
   >f(x) {if (x==1) return x; else return x*f(--x);}
   >df(x){if (x==1) return x; else return 1/x+df(--x);}
   >f(x=10pm1)
           3628800.00000 +/- 10628640.00000
   >(f(x)*df(x)*x.rms).val
           10628640.00000
\end{verbatim}
Similarly, the recurrence relations for the Laguerre polynomial of
order $n$ and its derivative evaluated at $x$ are given by
\begin{eqnarray}
&L_n(x)& = \left\{
	\begin{array}{lr}
	1&~~n=0\\
	1-x&~~n=1\\
	\frac{\left(2n-1-x\right)L_{n-1}(x)-\left(n-1\right)L_{n-2}(x)}{n}&~~n\ge2
	\end{array}
	\right. \\
&L^\prime_n(x)&  = \left(n/x\right)\left[L_n(x) - L_{n-1}(x)\right]
\end{eqnarray}
%&L_0(x)&         = 1~~~and~~~L_1(x)=1-x\nonumber \\ 
%&L_{n \ge 2}(x)& = (2n-1-x)L_{n-1}(x)-(n-1)L_{n-2}(x) \\
These are written as recursive functions {\tt l(n,x)} and {\tt
dl(n,x)} and it is shown that the propagated error in $L_n(x)$ is
equal to $L^\prime_n(x)\delta x$.
\begin{verbatim}
   >l(n,x){
      if (n<=0) return 1;
      if (n==1) return 1-x;
      return ((2*n-1-x)*l(n-1,x)-(n-1)*l(n-2,x))/n;
    }
   >dl(n,x){return (n/x)*(l(n,x)-l(n-1,x));}
   >l(4,x=3pm1)
               1.37500 +/-    0.50000
   >(dl(4,x)*x.rms).val
           0.50000
\end{verbatim}

\section{Syntax}
\label{APPEN:SYNTAX}

This section describes the syntax of the {\tt fussy} language.  Completed statements are
immediately compiled and executed.  Compiled code for the sub-programs (function or
procedure) is held in the memory and executed when the sub-programs are called.

\subsection{Numbers}
\label{NUMBERS}
Numbers in \Fussy\ are represented as floating point numbers and can
be specified with or without the decimal point, or in the exponent
format.  Optionally, an error can also be associated with the numbers
via the {\tt pm} directive.  E.g., $75.3\pm 10.1$ can be expressed as
{\tt 75.3pm10.1}.  Numbers (and variables) can also be tagged with units (see
Section~\ref{UNITS}) or a {\tt C}-styled printing format (see
Section~\ref{FORMATTING}).

\subsubsection{Units}
\label{UNITS}
   
Numerical values can be specified along with their units.  Currently, the only units
supported are degree, arcmin, arcsec, hours, minute, and seconds.  These can be specified
by appending {\tt 'd', ''', '"', 'h', 'm', 's'} respectively with the numeric values.
Internally, all numeric values are always stored in the MKS system of units.  The default
units for a variable used to specify angles or time is radians.  If the values are
specified along with any of the above mentioned units, the values are still stored
internally as radians.  However while printing (see Section~\ref{PRINT}), the values are
formatted automatically and printed with the appropriate units.

\subsection{Operators and built-in functions}

The normal binary operators of type {\tt expr <op> expr}, where {\tt expr} is any
expression/variable/constant and {\tt <op>} is one of {\tt '+', '-', '/', '*'},
'{\texttt{\^}}' and {\tt '**'} binary operators perform the usual mathematical operations
in addition to error propagation.  The comparison operators '{\texttt{<}}',
'{\texttt{>}}', '{\texttt{=}}', '{\texttt{!}}{\texttt{=}}', '{\texttt{<}}{\texttt{=}}',
'{\texttt{>}}{\texttt{=}}' and the logical operators '{\texttt{|}}{\texttt{|}}' and
'{\texttt{\&}}{\texttt{\&}}' have the usual meaning.  Apart from the usual operation, the
{\tt var=expr} assignment operator also propagates the error in the expression on the RHS
and assigns it as the error for the variable on the LHS.  Expressions like {\tt
  sin(x=0.1pm0.02)} are equivalent to {\tt x=0.1pm0.02;sin(x);}.  The prefix and
postfix operators {\tt <op>var} and {\tt var<op>} where {\tt <op>} is either {\tt '++'}
or {\tt '--'} and {\tt var} is any user-defined variable are also defined.  These
increment or decrement the value of the variables by one.  The prefix and postfix
operators operate on the variables before and after the variable is further used
respectively.

Two additional operators of type {\tt expr.<op>} where {\tt <op>} is either {\tt val} or
{\tt rms} are defined.  These operators return the value and the associated (propagated)
Root Mean Square error in {\tt expr} which can be any mathematical expression or a
variable.

\subsection{Partial assignment operator ``{\tt :=}''}
The partial assignment operator ``{\tt pvar:=expr}'' assigns value of partial results to
variables.  This does not propagate the errors on the RHS but instead transfers all the
required information for error propagation to the variable on the LHS (see
Section~\ref{APPEN:SUBEXPRESSIONS}).  Expressions like {\tt
  sin(x:=0.1pm0.02)} are equivalent to {\tt x:=0.1pm0.02;sin(x);}.
%The following built-in functions are available: {\tt sin}, {\tt cos},
%{\tt tan}, {\tt asin}, {\tt acos}, {\tt atan}, {\tt atan2}, {\tt
%sinh}, {\tt cosh}, {\tt tanh}, {\tt asinh}, {\tt acosh}, {\tt atanh},
%{\tt exp}, {\tt ln}, {\tt log}, {\tt fabs}, {\tt fmod}, {\tt sqrt}
%{\tt int}.  The following functions, useful for astronomical
%computations are defined.  The latitude and longitude used for these
%computations are set in the global system variables {\tt LONGITUDE}
%and {\tt LATITUDE}.
%\begin{itemize}
%\item {\tt time()}:  returns the current time in the {\tt hms} format.
%\item {\tt lst()}:   returns the Local Sideral time in the {\tt hms} format.
%\item {\tt day()}:   returns the current day.
%\item {\tt month()}: returns the current month.
%\item {\tt year()}:  returns the current year.
%\item {\tt mjd(),fmjd()}: returns the current MJD and fractional MJD.
%\item {\tt setlong(MyLongitude)}: Sets the global variables {\tt LONGITUDE}
%to the given value.
%\item {\tt setlat(MyLatitude)}: Sets the global variables {\tt LATITUDE}
%to the given value.
%\end{itemize}

\subsection{Expressions/Statements}
\label{APPEN:SYNTAX_EXPR}

Numbers and variables can be combined with the mathematical operators
and logical operators to form an expression.  Expressions can be used
as arguments to built-in or user-defined functions (see
Section~\ref{APPEN:SYNTAX_FUNC}).  An expression followed by a NEWLINE
prints its result on the output stream (see Section~\ref{PRINT}) in
the default format (see Section~\ref{FORMATTING}).

For the purpose of error propagation, the print statement and the
assignment operator (the ``{\tt =}'' operator but not the ``{\tt :=}''
operator; see Section~\ref{APPEN:SUBEXPRESSIONS}) are treated as the
terminal nodes of the parsing tree which invokes the final error
propagation.

Assigning a value to a variable also creates the variable.  The type
of the value assigned to the variable determines its type (and overrides
the value or the type of a previously declared variable).  E.g.
\begin{verbatim}
   >H_0=75pm10
   >H_0
             75.00000 +/-   10.00000
   >H_0="The Hubble constant\n"
   >H_0
    The Hubble constant
\end{verbatim}
A semi-colon ({\tt ';'}) is a delimiter to separate multiple expressions in a single
line.  Statements on separate lines need not be delimited by semi-colons (though it is
not an error to do so).  Compound statements are a group of simple statements, grouped
using the curly-brace pair ({\tt '\{'} and {\tt '\}'}) -- e.g. {\tt \{a=1.5;
  b=2;\}}). Compound statements can also be nested.  The {\tt '/\/*'} and {\tt '*/'} pair
can be used as comment delimiters.  Comment delimiters however cannot be nested.

\subsection{Sub-expressions}
\label{APPEN:SUBEXPRESSIONS}

A special assignment operator '{\tt :=}' is used to assign
sub-expressions to user-defined variables.  Sub-expression variables
are different from normal variables in that their propagated error is
computed on-the-fly when required, i.e.  when they are printed or are
assigned to a normal variable using the '{\tt =}' operator or at an
operator node of a parsing tree when used in another expression.  E.g.
\begin{verbatim}
   >x=1pm0.1
   >s:=sin(x);c:=cos(x);
   >sin(x)/cos(x) /* Compute tan(x) as sin(x)/cos(x) */
       1.55741 +/-    0.34255
   >s/c           /* Compute tan(x) using two PARTIAL_VAR */
       1.55741 +/-    0.34255
   >tan(x)        /* Direct computation of tan(x) */
       1.55741 +/-    0.34255
   >s2=s;
   >s2/c          /* Compute tan(x) with a normal variable
                     and one PARTIAL_VAR.  Error propagates 
                     differently */
       1.55741 +/-    0.26236
\end{verbatim}
\subsection{Variables and function/procedure names}

Variable/function/procedure names can be of any length and must match
the regular expression {\tt [a-zA-Z\_]+[a-zA-Z0-9\_]*}.  That is, the
names must start with an alphabet or {\tt '\_'} and can be followed by
one or more alpha-numeric characters or {\tt '\_'}.

\subsection{Function/procedure}
\label{APPEN:SYNTAX_FUNC}

Sub-programs can be written as functions or procedures.  The only
difference between functions and procedures is that functions {\it
must} return a value while procedures must {\it not} return a value.
The type of a sub-program which returns a value using the {\tt
return}~{\tt <expression>} statement becomes {\tt func}.  If {\tt
return} is not used, or is used without an {\tt expression}, the type
becomes {\tt proc}.  The type of the sub-program therefore need not be
declared.  It is an error to use a procedure in an expression or pass
a procedure as an argument to another sub-program where a function
is expected.

A function or procedure declaration begins with a variable name followed by an argument
list enclosed in the round bracket pair ({\tt '('} and {\tt ')'}).  A {\tt '()'}
specifies an empty argument list.  The function body is enclosed between the {\tt
  '\{'} and {\tt '\}'} brackets.  E.g.
\begin{verbatim}
   >/* An example of a funtion declaration */
   >f() { return sin(PI/2); }
   >/* An example of a procedure declaration */ 
   >p() {print "Value of f() = ",f(),"\n";}
   >f()
              1.00000
   >p() 
   Value of f() =    1.00000
\end{verbatim}
A sub-program can be passed as an argument to another sub-program.  An
argument corresponding to a sub-program can be specified using the
{\tt func} (for a function) or {\tt proc} (for a procedure) directive.
E.g.
\begin{verbatim}
   >f(x) { return sin(x); }
   >p(func fa,x) {print "The value of f(",x%5.2f,") =",fa(x),"\n";}
   >p(f,10)
   The value of f(10.00) =  -0.54402
\end{verbatim}
All symbols (variables, functions, procedures) used in the sub-program
code must be either global variables declared {\it before} the
sub-program declaration or must be one of the argument list.
Temporary variables, the scope of which is within the sub-program
only, can be declared using the {\tt auto} directive.  E.g.
\begin{verbatim}
   >f(x) { return sin(x); }
   >p(func fa,x)
     {
       auto t;
       t=fa(x);
       print "The value of f(",x%5.2f,") =",t,"\n";
     }
   >p(f,10)
   The value of f(10.00) =  -0.54402
\end{verbatim}


\subsection{Control statements}

The {\tt if-else}, {\tt while-} and {\tt for-}loops constitute the
program control statements.  These loops can be broken at any stage
with the use of the {\tt break} statement.  As of now, the conditions
which control the logic is evaluated ignoring the error with the
control variables.  Ultimately the goal is to provide a language
feature to specify a significance level and the conditional statements
return true if the error on the evaluated value is within the
significance level, else return false.

\subsubsection{{\tt if-else}}

The syntax for the {\tt if-else} statement is:
\begin{verbatim}
    if (condition)
       if-body-statment;

         or

    if (condition)
       if-body-statment else
       else-body-statment;
\end{verbatim}
The {\tt if-body-statement} and the {\tt else-body-statement} can be
any valid compound or simple statement.  In case of a simple
statement, the terminating semi-colon is necessary.

\subsubsection{{\tt while-loop}}

The syntax for the {\tt while-loop} is:
\begin{verbatim}
    while (condition)
       body-statment
\end{verbatim}
The {\tt body-statement} can be either a simple or a compound
statement and in case it is a simple statement, the terminating
semi-colon defines the end of the loop.

\subsubsection{{\tt for-loop}}

The syntax for the {\tt for-loop} is:
\begin{verbatim}
    for (init;condition;incr)
      body-statment
\end{verbatim}
where {\tt init} is a comma ({\tt ','}) separate list of simple
statements for initializing the loop variables.  E.g. {\tt init} can
be {\tt i=0,j=0,k=0}. {\tt condition} is a simple, single statement
while {\tt incr} is a list of comma separated statement(s). The {\tt
body-statement} can be any valid simple or compound statement.  {\tt
init} statements are executed first followed by the {\tt condition}
statement.  If the result of the {\tt condition} statement is non-zero
(logical true), the {\tt body-statements}, the {\tt incr} statement(s)
and the {\tt condition} statements are executed in a sequence till the
result of the {\tt condition} statement is zero (logical false).
E.g. following is a valid {\tt for-loop} with 3 loop-variables, only
one of which is checked in the condition:
\begin{verbatim}
    for (i=0,j=0,k=0;i<10;i=i+1,j=j+1;k=k+1) 
       print "i= ",i," j= ",j," k= ",k,"\n";
\end{verbatim}

\subsection{Print statement}
\label{PRINT}

The {\tt print} statement takes a comma separated list of objects to
be printed.  These objects can be quoted-strings, variables,
constants, condition statements or user-defined function names.  The
list can consist of any number of objects and is terminated by a
semi-colon.  The format in which the numeric values are printed is
defined by the format modifier associated with the values (see
Section~\ref{FORMATTING}).  All escaped-characters used in C-styled
printing have the same effect as in the output of the C-styled {\tt
printf} statement.

\subsection{Formatting}
\label{FORMATTING}

Values can be formatted for printing in a variety of ways.  The format
in which a variable is printed is associated with the variable and
consists of a {\tt printf} styled formatting string (with extensions
for specifying the units of the numerical values as well).  E.g., if
{\tt x=75pm10}, by default {\tt x} will be printed using the {\tt
'\%10.5f'} format.  The default print format can be modified using the
{\tt '.'} operator on a variable.  E.g., one can fix the default print
format of {\tt x} to {\tt '\%5.2f'} by {\tt x.=\%5.2f}.

The print format of a value can also be temporarily modified by
specifying the format along with the variable/value.  E.g. the value
of {\tt x} can be printed in the exponent format as {\tt print x\%E}
or in the in hexadecimal format as {\tt print x\%x}.

An extra formatting, not available in {\tt printf} formatting, is that
of printing the individual bit values using the {\tt \%b} format.
With this, the value is printed in binary (1 or 0) format.  {\tt
\%B} does the same thing except that it prints a space after every 8 bits.
The value is caste into a {\tt unsigned long} integer before
printing.
\begin{verbatim}
   >x=10;x%B
        00000000 00000000 00000000 00001010
\end{verbatim}
If the units of a value are specified, the print format is also
appropriately modified.  If a variable has units of time or angle, its
print format is automatically set to {\tt \%hms} or {\tt \%dms}
and are printed in the {\tt XXhXXmXX.XXs} and {\tt
XXdXX{\texttt{'}}XX.XX{\texttt{"}}} styles respectively.

\section{ACKNOWLEDGMENTS}
I thank D.~Oberoi and R.K.~Singh for many useful discussions and testing.  This work was
started and largely done while the I was at the National Center for Radio
Astrophysics (NCRA) of the Tata Institute of Fundamental Research (TIFR), Mumbai,
India and continued at my current position at the National Radio Astronomy Observatory
(NRAO), USA.  All of this work was done on computers running the GNU/Linux
operating system and I thank the numerous contributors to this software.

\end{document}
